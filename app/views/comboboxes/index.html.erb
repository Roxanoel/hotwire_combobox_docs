<header class="space-y-12">
  <%= image_tag "logo.png", class: "sm:h-72 mx-auto h-52" %>

  <h1 class="text-4xl font-black text-center">
    This is HotwireCombobox!
  </h1>

  <p class="max-w-2xl text-lg italic">
    NOTE: HotwireCombobox is at an early stage of development. It's nearing a beta release, but the API might change and bugs are expected. Please continue to use the library and report any issues in the GitHub repo.
  </p>

  <p class="max-w-2xl text-lg">
    It's a combobox (aka autocomplete) gem for Ruby on Rails apps that already use Hotwire.

    <br><br>At the very least, you should have Turbo and Stimulus installed and running in your app to use this gem.

    <br><br>Head to our <%= link_to "GitHub repo", "https://github.com/josefarias/hotwire_combobox", target: :_blank, rel: :noreferrer, class: "underline font-semibold" %>
    for installation instructions or read on for a quick demo.

    <br><br>HotwireCombobox prides itself on being easy to use. Let's dive into an implementation most people would think is complicated but this library makes simple.
  </p>
</header>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    YouTube-style autocomplete
  </h2>

  <div class="youtube">
    <%= form_with url: search_url do |form| %>
      <%= form.combobox :search, searchables_path,
            name_when_new: :search, mobile_at: "0px" %>
    <% end %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      <span class="font-bold">We'll get to a simpler example soon ðŸ˜„</span>. Bear with me for a second.

      <br><br>This search input is an async combobox. Go ahead. Use it!

      <br><br>It's fetching its options from the server by hitting <span class="whitespace-nowrap font-mono font-semibold">searchables_path</span>
      and expecting a Turbo Stream template in return. If you scroll down far enough, you'll see the options are loaded
      in batches.

      <br><br>Below is all the code you need to create one of these. It's okay if you don't understand everything yet. You will. But for now,
      know that this is as complicated as it will get.
    </p>

    <%=
      highlight_erb(%(
        &lt;%= form_with url: search_url do |form| %&gt;
          &lt;%= form.combobox :search, searchables_path,
                name_when_new: :search, mobile_at: "0px" %&gt;
        &lt;% end %&gt;
      ), "In views/search/new.html.erb")
    %>

    <%=
      highlight_erb(%(
        &lt;%= paginated_combobox_options @page.records,
              for_id: "search",
              render_in: { partial: "searchables/searchable" },
              next_page: @page.last? ? nil : @page.next_param %&gt;
      ), "In views/searchables/index.turbo_stream.erb")
    %>

    <p class="max-w-2xl text-lg">
      <span class="font-bold">That's it!</span>

      <br><br>You'll still need to implement the CSS styling, partials for each rendered option,
      and the back-end search and pagination logic. But even that is only maybe 20 lines of code.

      <br><br>Now, before I explain all the options you can pass to the combobox, let's take a look at
      that simpler example I promised.
    </p>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    A basic combobox
  </h2>

  <div>
    <%= combobox_tag "state", State.all %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      This is a basic combobox. As plain as can be. Click on it to view all the options. Start typing to filter them down. Here's the code for it:
    </p>

    <%=
      highlight_erb(%(
        &lt;%= combobox_tag "state", State.all %&gt;
        &lt;%# Of course these aren't actually all the US states. %&gt;
        &lt;%# I've selected a few at random for this demo. %&gt;
      ))
    %>

    <p class="max-w-2xl text-lg">
      The first param corresponds to the input's name. It's what the query param will be called when the form is submitted.

      <br><br>The second param is the collection of options. It can either be an <span class="whitespace-nowrap font-mono font-semibold">ActiveRecord::Relation</span>,
      an array of <span class="whitespace-nowrap font-mono font-semibold">Hash</span> objects, or a url/path helper.

      <br><br><span class="whitespace-nowrap font-mono font-semibold">ActiveRecord::Relation</span> and <span class="whitespace-nowrap font-mono font-semibold">Hash</span> objects will load all the options at once.
      Filtering is done out of the box by the gem. If you pass a url/path helper, filtering is done asynchronously server-side.
    </p>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    An async combobox
  </h2>

  <div>
    <%= combobox_tag "state", states_path, id: "state-box" %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      Async comboboxes are useful because no time is spent loading all the options before the page is rendered. Instead, options are fetched when the combobox is first opened.
      You might reach for one of these when you're filtering a large dataset.

      <br><br>They have some requirements that inline comboboxes don't. For starters, they need an <span class="whitespace-nowrap font-mono font-semibold">id</span>.
      This id is automatically determined when using the form helper from the YouTube-style example. But we're not using it here, so we need to provide it.
      Note that this <span class="whitespace-nowrap font-mono font-semibold">id</span>, regardless of whether it was inferred in the form helper or passed manually,
      is always available in the combobox's <span class="whitespace-nowrap font-mono font-semibold">data-async-id</span> attribute, for convenience.

      <br><br>Async comboboxes also require you to do the filtering server-side. Whenever the user types into the input, the combobox will perform a debounced request to your server
      to the url or path you provided. The user's input will be sent as a param accessible via <span class="whitespace-nowrap font-mono font-semibold">params[:q]</span>.

      <br><br>Finally, you'll have to provide the options via the gem's <span class="whitespace-nowrap font-mono font-semibold">#paginated_combobox_options</span> helper.

      <br><br>Here's what all that might look like:
    </p>

    <%=
      highlight_erb(%(
        &lt;%= combobox_tag "state", states_path, id: "state-box" %&gt;
      ), "In your template")
    %>

    <%=
      highlight_rb(%(
        class StatesController &lt; ApplicationController
          def index
            @states = State.search params[:q]
          end
        end
      ), "In your controller")
    %>

    <%=
      highlight_erb(%(
        &lt;%= paginated_combobox_options @states, for_id: "state-box" %&gt;
      ), "In views/states/index.turbo_stream.erb")
    %>

    <p class="max-w-2xl text-lg">
      You can optionally paginate the options. Simply pass the next page number as <span class="whitespace-nowrap font-mono font-semibold">:next_page</span> to <span class="whitespace-nowrap font-mono font-semibold">#paginated_combobox_options</span>.
      When the user scrolls down far enough,
      the combobox will automatically request that page number in a param accessible via <span class="whitespace-nowrap font-mono font-semibold">params[:page]</span> to the same url or path you provided.
    </p>

    <%=
      highlight_erb(%(
        &lt;%# This is using geared_pagination syntax %&gt;
        &lt;%= paginated_combobox_options @page.records,
              for_id: "state-box",
              next_page: @page.last? ? nil : @page.next_param %&gt;
      ), "In views/states/index.turbo_stream.erb")
    %>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    An HTML combobox
  </h2>

  <div>
    <%= combobox_tag "state", State.all,
          render_in: { partial: "states/state" } %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      You can pass a full set of rendering options to the combobox. It'll use those options to render each item in the list.
      Rendering HTML inside the dropdown is as simple as creating a standard partial:
    </p>

    <%=
      highlight_erb(%(
        &lt;%= combobox_tag "state", State.all,
              render_in: { partial: "states/state" } %&gt;
      ), "In your template")
    %>

    <p class="max-w-2xl text-lg">
      As you saw from the YouTube-style example, <span class="whitespace-nowrap font-mono font-semibold">:render_in</span> is also supported
      in async comboboxes. Simply include the rendering options in the Turbo Stream template.
    </p>

    <%=
      highlight_erb(%(
        &lt;%= paginated_combobox_options @page.records,
              for_id: "state-box",
              render_in: { partial: "states/state" },
              next_page: @page.last? ? nil : @page.next_param %&gt;
      ), "In views/states/index.turbo_stream.erb")
    %>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    A mobile combobox
  </h2>

  <div>
    <%= combobox_tag "state", State.all, mobile_at: "640px" %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      NOTE: This seems to be broken for mobile Safari at the moment.<br><br>

      If you're reading this on a mobile device, this may not come as a surprise.
      But these comboboxes behave differently on desktop and mobile.

      <br><br>On mobile, the options will appear inside a native HTML dialog element.
      You can style this however you want. But, by default, the options list will take up the full width
      of the screen and almost the full height.

      <br><br>You can configure the breakpoint at which the combobox switches to mobile mode
      by passing a <span class="whitespace-nowrap font-mono font-semibold">:mobile_at</span> option,
      which takes any valid CSS width value.

      Try opening the above combobox on a small screen!
    </p>

    <%=
      highlight_erb(%(
        &lt;%= combobox_tag "state", State.all, mobile_at: "640px" %&gt;
      ))
    %>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    A prefilled combobox
  </h2>

  <div>
    <%= form_with model: @user, url: user_url(@user) do |form| %>
      <%= form.combobox :favorite_movie_id, Movie.all %>
    <% end %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      You can prefill a combobox with a value.

      <br><br>This is most commonly done when using the form builder to edit a record.
      The library knows how to use the method name (in this example <span class="whitespace-nowrap font-mono font-semibold">:favorite_movie_id</span>)
      to find the value and prefill the input. The dropdown option will be preselected as well.
    </p>

    <%=
      highlight_erb(%(
        &lt;%= form_with model: @user, url: user_url(@user) do |form| %&gt;
          &lt;%= form.combobox :favorite_movie_id, Movie.all %&gt;
        &lt;% end %&gt;
      ))
    %>

    <p class="max-w-2xl text-lg">
      When the combobox is async, the library can infer associations based on the presence of the <span class="whitespace-nowrap font-mono font-semibold">_id</span> suffix.
      If an association is found, the associated object is loaded and used to prefill the input. You can also provide the
      association name yourself via the <span class="whitespace-nowrap font-mono font-semibold">:association_name</span> option.

      <br><br>When not using the form builder, you can pass a <span class="whitespace-nowrap font-mono font-semibold">:value</span> option to the combobox.
      It will be prefilled if an option is found with the same value.
    </p>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    A free text combobox
  </h2>

  <div>
    <%= form_with model: @user, url: user_url(@user) do |form| %>
      <%= form.combobox :favorite_movie_id, Movie.all,
            name_when_new: "user[favorite_movie_attributes][name]" %>
    <% end %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      Sometimes you want to allow the user to enter a value that isn't in the list of options.
      This is called a free text combobox.

      <br><br>In most cases this will be because you're using the combobox to either select an existing record or create a new one.

      <br><br>The library knows whether the input value is in the list of options. If it's not, it will use the <span class="whitespace-nowrap font-mono font-semibold">:name_when_new</span> option
      to set a new name for the form field. If you switch back to an existing option, the name will be reset to the original.

      <br><br>It's the presence of the <span class="whitespace-nowrap font-mono font-semibold">:name_when_new</span> that tells the
      combobox it should allow free text. If it's not present, then free text is not allowed.

      <br><br>Note that there's nothing stopping you from using the same name for both the combobox and the <span class="whitespace-nowrap font-mono font-semibold">:name_when_new</span> opion,
      like in the YouTube-style example.

      <br><br>One way you might use this is in conjunction with Rails's <span class="whitespace-nowrap font-mono font-semibold">accepts_nested_attributes_for</span> feature.
    </p>

    <%=
      highlight_erb(%(
        &lt;%= form_with model: @user, url: user_url(@user) do |form| %&gt;
          &lt;%= form.combobox :favorite_movie_id, Movie.all,
                name_when_new: "user[favorite_movie_attributes][name]" %&gt;
        &lt;% end %&gt;
      ))
    %>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    Styling
  </h2>

  <div class="youtube">
    <%= form_with url: search_url do |form| %>
      <%= form.combobox :search, [] %>
    <% end %>
  </div>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      We've come full circle to the original YouTube-style combobox. But this time, let's talk about styling.

      <br><br>You can opt-in to the default styles by including the gem's CSS file in your document's head.
      You can do that via the <span class="whitespace-nowrap font-mono font-semibold">#combobox_style_tag</span> helper.
      You can pass any of the usual <span class="whitespace-nowrap font-mono font-semibold">#stylesheet_link_tag</span> options to it.

      <br><br>Regardless of whether you've included the default styles, you always have full control over the combobox's appearance.
      Simply override these classes in your CSS:
    </p>

    <ul class="max-w-2xl text-lg">
      <li><span class="font-semibold">.hw-combobox</span>: the fieldset container, wraps the whole component</li>
      <li><span class="font-semibold">.hw-combobox__input</span>: the field where the user inputs text</li>
      <li><span class="font-semibold">.hw-combobox__handle</span>: the chevron or downwards arrow</li>
      <li><span class="font-semibold">.hw-combobox__listbox</span>: the collapsible options container</li>
      <li><span class="font-semibold">.hw-combobox__option</span>: each individual option</li>
      <li><span class="font-semibold">.hw-combobox__option--selected</span>: the currently selected option</li>
      <li><span class="font-semibold">.hw-combobox__dialog</span>: contains the input, listbox, and options when on mobile mode</li>
      <li><span class="font-semibold">.hw-combobox__dialog__label</span>: optional label displayed on mobile mode</li>
      <li><span class="font-semibold">.hw-combobox__dialog__input</span>: mobile mode input</li>
      <li><span class="font-semibold">.hw-combobox__dialog__listbox</span>: mobile mode listbox</li>
    </ul>

    <p class="max-w-2xl text-lg">
      You can also override the CSS variables defined by the library. Look in the source code for the full list of variables.

      <br><br>Here's one way you could style the combobox to look like the YouTube-style example using Tailwind:
    </p>

    <%=
      highlight_css(%(
        .youtube {
          --hw-handle-image: url("data:image/svg+xml;charset=utf-8,/* magnifying glass svg */");
        }

        .youtube { @apply flex items-center justify-center w-full; }
        .youtube .hw-combobox__input { @apply sm:w-[35rem] rounded-full w-80; }
        .youtube .hw-combobox__handle { @apply right-3; }
        .youtube .hw-combobox__listbox { @apply rounded-2xl; }
      ))
    %>
  </div>
</article>

<article class="flex flex-col items-center w-full space-y-16">
  <h2 class="text-3xl font-black text-center">
    Other options
  </h2>

  <div class="flex flex-col items-center w-full space-y-8">
    <p class="max-w-2xl text-lg">
      Here's a quick list of other options you can pass to the combobox:
    </p>

    <ul class="max-w-2xl text-lg">
      <li><span class="font-semibold">:autocomplete</span> â€” choose one of :list, :inline, or :both, defaults to :both</li>
      <li><span class="font-semibold">:dialog_label</span> â€” text for the optional label displayed on mobile mode, defaults to nil</li>
      <li><span class="font-semibold">:input</span> â€” HTML options to be forwarded to the input, defaults to {}</li>
      <li><span class="font-semibold">:open</span> â€” whether the combobox should be open on first render, defaults to false</li>
    </ul>

    <p class="max-w-2xl text-lg">
      Any other unrecognized options are forwarded to the input element.
    </p>
  </div>
</article>
